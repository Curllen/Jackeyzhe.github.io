<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代码洁癖系列（一）：什么是整洁代码]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[作为一个代码洁癖患者，我最大的愿望就是世界和平……对不起，拿错剧本了，最大的愿望就是将对代码的洁癖传播给每一个人，净化所有的代码。这是一个宏大的愿望，但我会一直努力净化我所看到的每一行代码，并且希望能影响更多的人，让大家都写出整洁的代码。 在阅读本文之前，想先提两个问题： 你是程序员吗 你想成为更好的程序员吗 如果上面两个回答都是肯定的，那请你继续读下去，否则就可以直接关闭网页了。 什么是整洁代码相信有过一定工作经验的程序员都读过别人的代码，也一定看到过槽糕的代码，看到那些糟糕的代码时你是不是在想：这写的什么垃圾东西，读懂这段代码所花费的时间我都能把这个功能再实现一遍了。还有另一种情况：引用别人的代码时，为了能按时完成，不得不去适应别人的代码风格，跟着制造混乱。当混乱越来越多时，整个团队的生产力也越来越低，直到最后不得不把所有代码重新整理一遍，而这个工作里可想而知。 上面说的都是糟糕的代码所带来的影响。那么什么是整洁的代码呢？在我看来可以从两个方面定义整洁代码： 外在美 外观看起来优雅美观的代码会使人心情愉悦。其中主要体现在：代码所在的位置是否恰当，代码里是否有适当的注释，适当的缩进和空行以及没有重复代码等等。 内在美 外在美只是“看起来”使人心情愉悦，如果缺乏内在美，那么当别人真正开始读的时候，刚才愉悦的心情会在一瞬间烟消云散。而内在美则体现在：尽量少的API，代码之间的尽量少的依赖，干净利落的抽象和直截了当的控制语句等。 在理解了什么是整洁代码后，希望我们在写每一行代码之前都要思考一下，这行代码是否足够整洁，是否让人看了心情愉悦。 之后的一段时间，我也将会从以下几个方面和大家分享，如何写出整洁的代码。 有意义的命名什么是无意义的命名？如果代码中所有的变量名，函数名都是abcd之类的，相信你在看到这样一段代码的第一眼就已经失去了读下去的欲望了。也许有人觉得这太极端了，认为不会有人这样写代码。那么我们在考虑一下，我为一个变量命名为name，那么在没有前后语境的情况下，你能想象出这个变量是用来做什么的吗？是一个人的name还是一个物品的name，是firstName还是lastName？所以，有意义的命名对代码阅读是非常重要的。 如何定义类和函数如何定义相信大家都会，毕竟这是最基本的操作，那么怎么才能算是整洁的类和函数呢？ 要不要写注释大多数程序员都觉得写注释（文档）很麻烦，觉得自己的工作就是实现功能，自己写的代码自己能看懂就行。事实上真的是这样吗，他们真的能看懂自己三个月前写的代码吗？ 另一种程序员知道要写注释，但是他们写的注释都是诸如：“这是一个方法”、“这是一个循环”……这样的注释写出来真的有意义吗？ 如何排版这个属于外在美，第一印象很重要，第一眼看上去很好，才会继续看下去不是吗。 错误处理代码运行时的错误如何处理吗？全部抛出去，交个用户处理？全部catch住，隐藏起来不处理？这两种程序员相信都会被老板当成错误处理掉吧。 合格的单元测试什么样的单元测试才算合格，单元测试对代码的覆盖率要达到多少？ 迭代胖子从来都不是一口吃成的，怎么才能让你的代码越来越饱满，系统越来越稳定呢？唯有不断迭代。 结语上面这些问题，我将在后面的文章中挨个解读。希望你读完之后，也能化身为整洁代码的守护者。]]></content>
      <tags>
        <tag>瞎扯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java原子操作类，知多少？]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%8C%E7%9F%A5%E5%A4%9A%E5%B0%91%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前文我们介绍了Java并发编程中的两个关键字：volatile和synchronized。我们也知道了volatile虽然是轻量级，但不能保证原子性，synchronized可以保证原子性，但是比较重量级。 那么有没有一种简单的、性能高的方法来保证Java的原子操作呢？答案当然是有的，本文就为大家揭秘一些在JDK1.5时期加入Java家族的成员——Atomic包。Atomic包下包含了12个类，分为4种类型： 原子更新基本类型 原子更新数组 原子更新引用 原子更新字段 下面我来为大家一一引荐。 原子基本类型原子基本类型，从名称上就可以看出，是为基本类型提供原子操作的类。它们是以下3位： AtomicBoolean AtomicInteger AtomicLong 这三位属于近亲，提供的方法基本一模一样（AtomicBoolean支持方法略少）。 这里我们以AtomicInteger为例介绍这些方法。 void lazySet(int newValue)：使用此方法后最终会被设置成newValue。是线程不安全的。官方解释如下： As probably the last little JSR166 follow-up for Mustang, we added a “lazySet” method to the Atomic classes (AtomicInteger, AtomicReference, etc). This is a niche method that is sometimes useful when fine-tuning code using non-blocking data structures. The semantics are that the write is guaranteed not to be re-ordered with any previous write, but may be reordered with subsequent operations (or equivalently, might not be visible to other threads) until some other volatile write or synchronizing action occurs). The main use case is for nulling out fields of nodes in non-blocking data structures solely for the sake of avoiding long-term garbage retention; it applies when it is harmless if other threads see non-null values for a while, but you’d like to ensure that structures are eventually GCable. In such cases, you can get better performance by avoiding the costs of the null volatile-write. There are a few other use cases along these lines for non-reference-based atomics as well, so the method is supported across all of the AtomicX classes. For people who like to think of these operations in terms of machine-level barriers on common multiprocessors, lazySet provides a preceeding store-store barrier (which is either a no-op or very cheap on current platforms), but no store-load barrier (which is usually the expensive part of a volatile-write). 这里解释道：此方法不可与之前的写操作进行重排序，可以与之后的写操作进行重排序，知道出现volatile写或synchronizing操作。好处是比普通的set方法性能要好，前提是可以忍受其他线程在一段时间内读到的是旧数据。 int getAndSet(int newValue)：以原子方式更新，并且返回旧值。 boolean compareAndSet(int expect, int update)：如果输入的值等于expect的值，则以原子方式更新。 int getAndIncrement()：以原子方式自增，返回的是自增前的值。 int getAndDecrement()：与getAndIncrement相反，返回的是自减前的值。 int getAndAdd(int delta)：以原子方式，将当前值与输入值相加，返回的是计算前的值。 int incrementAndGet()：以原子方式自增，返回自增后的值。 int decrementAndGet()：以原子方式自减，返回自减后的值。 int addAndGet(int delta)：以原子方式，将当前值与输入值相加，返回的是计算后的值。 int getAndUpdate(IntUnaryOperator updateFunction)：Java1.8新增方法，以原子方式，按照指定方法更新当前数值，返回更新前的值，需要注意的是，提供的方法应该无副作用（side-effect-free），即两次执行结果相同，原因是如果由于线程争用导致更新失败会尝试再次执行该方法。 int updateAndGet(IntUnaryOperator updateFunction)：同样是Java1.8新增方法，与getAndUpdate唯一不同的是返回值是更新后的值。 int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)：与上述两个方法类似，操作数由参数x提供。返回更新前的值。 int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)：与getAndAccumulate方法作用相同，返回更新后的值。 方法介绍完了，AtomicInteger是怎么实现原子操作的呢？一起来看一下getAndIncrement方法的源码。 12345678/** * Atomically increments by one the current value. * * @return the previous value */public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 继续看Unsafe方法里的getAndIncrement方法 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 其中getIntVolatile方法是一个本地方法，根据对象以及偏移量获取对应的值。然后执行compareAndSwapInt方法，该方法根据对象和偏移量获取当当前值，与希望的值var5比较，如果相等，则将值更新为var5+var4。否则，进入循环。如果想要了解UnSafe类的其他方法，可以阅读源码或者参考这篇文章Java中Unsafe类详解。 原子数组下面的类是为数组中某个元素的更新提供原子操作的类。 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 这三个类中的方法也都是类似的： 我们对AtomicIntegerArray中的方法进行介绍。 AtomicIntegerArray(int length)：构造函数，新建一个数组，传入AtomicIntegerArray。 AtomicIntegerArray(int[] array)：构造函数，将array克隆一份，传入AtomicIntegerArray，因此，修改AtomicIntegerArray中的元素时不会影响原数组。 int length()：获取数组长度。 int get(int i)：获取位置i的元素。 void set(int i, int newValue)：设置对应位置的值。 void lazySet(int i, int newValue)：类似AtomicInteger中的lazySet。 int getAndSet(int i, int newValue)：更新对应位置的值，返回更新前的值。 boolean compareAndSet(int i, int expect, int update)：比较对应位置的值与期望值，如果相等，则更新，返回true。如果不能返回false。 int getAndIncrement(int i)：对位置i的元素以原子方式自增，返回更新前的值。 int getAndDecrement(int i)：对位置i的元素以原子方式自减，返回更新前的值。 int getAndAdd(int i, int delta)：对位置i的元素以原子方式计算，返回更新前的值。 int incrementAndGet(int i)、int decrementAndGet(int i)、addAndGet(int i, int delta)：这三个方法与上面三个方法操作相同，区别是这三个方法返回的是更新后的值。 下面四个方法都是1.8才加入的，根据提供的参数中的方法对位置i的元素进行操作。区别是返回值不同以及是否提供操作数。 int getAndUpdate(int i, IntUnaryOperator updateFunction) int updateAndGet(int i, IntUnaryOperator updateFunction) int getAndAccumulate(int i, int x, IntBinaryOperator accumulatorFunction) int accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction) 原子数组类型同样也是调用Unsafe类的方法，因此原理与基本类型的原理相同，这里不做赘述。 原子引用类型前面讲到的类型都只能以原子的方式更新一个变量，有没有办法以原子方式更新多个变量呢？我们可以利用了面向对象的封装思想，可以把多个变量封装成一个类，再以原子的方式更新一个类对象。幸运的是，Atomic为我们提供了更新引用类型的方法。一起来认识一下他们吧。 AtomicReference AtomicReferenceFieldUpdater AtomicMarkableReference 同样的，先来看一下这三个类提供的方法有哪些。 方法的作用与AtomicInteger中的方法类似，不做过多介绍。 1234567891011/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */public final boolean compareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update);&#125; 这是compareAndSet方法的源码，同样是调用UnSafe类的CAS方法，因此，原子操作的原理也和基本类型相同。 原子更新字段类前文提到了AtomicReferenceFieldUpdater类，它更新的是类的字段，除了这个类，Atomic还提供了另外三个类用于更新类中的字段： AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicStampedReference 使用这些类时需要注意以下几点： 更新字段必须有volatile关键字修饰 更新字段不能是类变量 使用前需要调用newUpdater()方法创建一个Updater 这三个类的方法语义也很明确，可以参考AtomicInteger。 总结Atomic包提供了足够的原子类供我们使用，想要真正完全理解这些类，还需要不断的练习。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile vs synchronized]]></title>
    <url>%2F2018%2F08%2F20%2Fvolatile-vs-synchronized%2F</url>
    <content type="text"><![CDATA[今天来聊一聊Java并发编程中两个常用的关键字：volatile和synchronized。 在介绍这两个关键字之前，首先要搞明白并发编程中的两个问题： 线程之间是如何通信的 线程之间如何同步 Java内存模型Java线程的通信由Java内存模型（JMM）控制，Java内存模型的抽象如图： Java线程之间的通信总是隐式进行，通信过程对程序员完全透明。多个线程通过读-写共享内存来实现通信。 图中线程A与线程B通信的具体步骤是： 线程A把更新过的共享变量刷新到主内存中 线程B从主内存读取共享变量 例如，共享变量x的初始值为0，线程A将x修改为1（x=x+1），线程B读取到的x就是1，对于程序员来讲，就是线程A给线程B发消息说它把x的值更新为1。 第一个问题搞明白了，再思考一下第二个问题。线程之间如何同步？在并发编程中，有三个重要的概念：原子性、可见性、一致性。 原子性在Java中，对基本数据类型的读取和赋值操作都属于原子操作。 12x = 10;x = x + 1; 上面两条语句中，第一句是原子操作，而第二句不是，为什么呢？实际上，第二句代码被编译为3条指令： 从内存中取x的值 x+1操作 计算结果存入内存 可见性当多个线程访问同一变量时，如果有一个线程修改了这个变量，那么其他线程立刻可以看到修改后的值。 有序性CPU执行指令是按照先后顺序执行的，但是指令的顺序并不一定等同于代码的顺序，编译器编译过程中，为了提高性能，常常进行指令重排序。这种重排序不会改变单线程的语义，也就是说，你写的一段代码如果是单线程执行，编译器可能对执行进行重排序，但不论如何排序，最后得到的结果都是相同的。 另外，如果存在数据依赖性，编译器不会改变依赖关系的执行顺序。数据依赖性是指两个操作访问同一个变量，其中一个是写操作，那么这两个操作就有数据依赖性。 重排序对应多线程有哪些影响呢，我们通过一段代码来看一下： 1234567891011121314class ReorderExample &#123; int a = 0; boolean flag = false; public void writer() &#123; a = 1; // 1 flag = true; // 2 &#125; Public void reader() &#123; if (flag) &#123; // 3 int i = a * a; // 4 …… &#125; &#125;&#125; 上述代码中，flag是变量a被初始化的标识，如果此时有两个线程A和B，A执行writer()方法，B执行reader()方法。由于1和2、3和4不存在数据依赖性，那么就有可能出现这种情况： A先执行语句2 B执行了语句3和4 A执行语句1 最终的结果并不是我们想要的，此时，重排序破坏了语义。 线程同步对于上面所说的线程同步问题如何避免呢？可以使用Java中的volatile和synchronized这两个关键字。 volatilevolatile关键字比较轻量级，只可以修饰变量。volatile修饰的变量，如果值被更新，会立即刷新主内存，而读volatile修饰的变量时，JMM会把线程对应的本地内存置为无效，从主内存中读取。这样volatile就可以保证线程的可见性。 volatile关键字在一定程度上可以保证有序性： 当第二个操作是volatile写时，不能进行重排序 当第一个操作是volatile读时，不能进行重排序 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序 为了实现这些语义，JMM采用屏障插入策略： 在volatile写操作前插入StoreStore屏障，后面插入StoreLoad屏障 在volatile读操作后面插入LoadLoad屏障和LoadStore屏障 也就是说，volatile写操作前的所有写操作都必须执行完，且需要等到volatile写操作执行后才能执行读操作。volatile读操作执行完之后才可以进行其他操作。也就是说volatile相当于一个屏障，其前面的操作不能放到volatile操作后面，后面的操作也不能放到volatile操作前面。 synchronizedsynchronized比较重量级，可以用来修饰方法。synchronized关键字是给修饰对象加锁，只有获得锁的线程才可以执行，执行完后释放锁。因此synchronized保证了原子性和可见性。 文中图片来源于网络]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Git原理]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%81%8A%E8%81%8AGit%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[说起Git，相信大家都很熟悉了，毕竟作为程序猿，每天的业余时间除了吃饭睡觉就是逛一下全世界最大的开（tong）源（xing）代（jiao）码（you）网站GitHub了。在那里Git是每个人所要具备的最基本的技能。今天我们不聊Git的基本应用，来聊一聊Git的原理。 Git给自己的定义是一套内存寻址文件系统，当你在一个目录下执行git init命令时，会生成一个.git目录，它的目录结构是这样的： 1234567891011121314151617181920212223.git/├── branches├── config├── description├── HEAD├── hooks│ ├── applypatch-msg.sample│ ├── commit-msg.sample│ ├── post-update.sample│ ├── pre-applypatch.sample│ ├── pre-commit.sample│ ├── prepare-commit-msg.sample│ ├── pre-push.sample│ ├── pre-rebase.sample│ └── update.sample├── info│ └── exclude├── objects│ ├── info│ └── pack└── refs ├── heads └── tags 其中branches目录已经不再使用，description文件仅供GitWeb程序使用，config文件保存了项目的配置。 需要我们重点关注的是HEAD和index文件以及objects和refs目录。其中index中保存了暂存区的一些信息，这里不做过多介绍。 objects目录这个目录是用来存储Git对象的（包括tree对象、commit对象和blob对象），对于一个初始的Git仓库，objects目录下只有info和pack两个子目录，并没有常规文件。随着项目的进行，我们创建的文件，以及一些操作记录，都会作为Git对象被存储在这个目录下。 在该目录下，所有对象都会生成一个文件，并且有对应的SHA-1校验和，Git会创建以校验和前两位为名称的子目录，并以剩下的38位为名称来保存文件。 接下来让我们一起看一下当我们进行一次提交时，Git具体做了哪些事情。 12$ echo 'test content'&gt;test.txt$ git add . 执行上述命令后，objects目录结构如下： 12345.git/objects/├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── info└── pack 这里多了一个文件夹，如上面所述，这个就是Git为我们创建的一个对象，我们可以使用底层命令来看一下这个对象的类型以及它存储的是什么。 1234$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4blob$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4test content 可以看到，这是一个blob对象，存储内容就是我们刚刚创建的文件的内容。接下来继续执行提交操作。 1234567891011121314$ git commit -m 'test message'[master (root-commit) 2b00dca] test message 1 file changed, 1 insertion(+) create mode 100644 test.txt $ tree .git/objects/.git/objects/├── 2b│ └── 00dcae50af70bb5722033b3fe75281206c74da├── 80│ └── 865964295ae2f11d27383e5f9c0b58a8ef21da├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── info└── pack 此时objects目录下又多了两个对象。再用cat-file命令来查看一下这两个文件。 123456789101112$ git cat-file -t 2b00dcae50af70bb5722033b3fe75281206c74dacommit$ git cat-file -p 2b00dcae50af70bb5722033b3fe75281206c74datree 80865964295ae2f11d27383e5f9c0b58a8ef21daauthor jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534670725 +0800committer jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534670725 +0800test message$ git cat-file -t 80865964295ae2f11d27383e5f9c0b58a8ef21datree$ git cat-file -p 80865964295ae2f11d27383e5f9c0b58a8ef21da100644 blob d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt 可以看到一个是commit对象，一个是tree对象。commit对象通常包括4部分内容： 工作目录快照的Hash，即tree的值 提交的说明信息 提交者的信息 父提交的Hash值 由于我是第一次提交，所以这里没有父提交的Hash值。 tree对象可以理解为UNIX文件系统中的目录，保存了工作目录的tree对象和blob对象的信息。接下来我们再来看一下Git是如何进行版本控制的。 123456789101112131415161718192021222324252627282930313233343536373839echo 'version1'&gt;version.txt$ git add .$ git commit -m 'first version'[master 702193d] first version 1 file changed, 1 insertion(+) create mode 100644 version.txt$ echo 'version2'&gt;version.txt$ git add .$ git commit -m 'second version'[master 5333a75] second version 1 file changed, 1 insertion(+), 1 deletion(-)$ tree .git/objects/.git/objects/├── 1f│ └── a5aab2a3cf025d06479b9eab9a7f66f60dbfc1├── 29│ └── 13bfa5cf9fb6f893bec60ac11d86129d56fcbe├── 2b│ └── 00dcae50af70bb5722033b3fe75281206c74da├── 53│ └── 33a759c4bdcdc6095b4caac19743d9445ca516├── 5b│ └── dcfc19f119febc749eef9a9551bc335cb965e2├── 70│ └── 2193d62ffd797155e4e21eede20897890da12a├── 80│ └── 865964295ae2f11d27383e5f9c0b58a8ef21da├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── df│ └── 7af2c382e49245443687973ceb711b2b74cb4a├── info└── pack$ git cat-file -p 1fa5aab2a3cf025d06479b9eab9a7f66f60dbfc1100644 blob d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt100644 blob 5bdcfc19f119febc749eef9a9551bc335cb965e2 version.txt$ git cat-file -p 2913bfa5cf9fb6f893bec60ac11d86129d56fcbe100644 blob d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt100644 blob df7af2c382e49245443687973ceb711b2b74cb4a version.txt Git将没有改变的文件的Hash值直接存入tree对象，对于有修改的文件，则会生成一个新的对象，将新的对象存入tree对象。我们再来看一下commit对象的信息。 1234567891011121314$ git cat-file -p 5333a759c4bdcdc6095b4caac19743d9445ca516tree 2913bfa5cf9fb6f893bec60ac11d86129d56fcbeparent 702193d62ffd797155e4e21eede20897890da12aauthor jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672270 +0800committer jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672270 +0800second version$ git cat-file -p 702193d62ffd797155e4e21eede20897890da12atree 1fa5aab2a3cf025d06479b9eab9a7f66f60dbfc1parent 2b00dcae50af70bb5722033b3fe75281206c74daauthor jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672248 +0800committer jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672248 +0800first version 此时的commit对象已经有parent信息了，这样我们就可以顺着parent一步步往回进行版本回退了。不过这样是比较麻烦的，我们一般习惯用的是git log查看提交记录。 refs目录在介绍refs目录之前，我们还是先来看一下该目录结构 123456789$ tree .git/refs/.git/refs/├── heads│ └── master└── tags2 directories, 1 file$ cat .git/refs/heads/master 5333a759c4bdcdc6095b4caac19743d9445ca516 在一个刚刚被初始化的Git仓库中，refs目录下只有heads和tags两个子目录，由于我们刚刚有过提交操作，所以git为我们自动生成了一个名为master的引用。master的内容是最后一次提交对象的Hash值。看到这里大家一定在想，如果我们对每次提交都创建一个这样的引用，不就不需要记住每次提交的Hash值了，只要看看引用的值，复制过来就可以退回到对应版本了。没错，这样是可以方便的退回，但是这样做的意义不大，因为我们并不需要频繁的退回，特别是比较古老的版本，退回的概率更是趋近于0。Git用这个引用做了更有意义的事，那就是分支。 当我新建一个分支时，git就会在.git/refs/heads目录下新建一个文件。当然新建的引用还是指向当前工作目录的最后一次提交，一般情况下我们不会主动去修改这些引用文件，不过如果一定要修改，Git为我们提供了一个update-ref命令。可以改变引用的值，使其指向不同的commit对象。 tags目录下的文件存储的是标签对应的commit，当为某次提交打上一个tag时，tags目录下就会被创建出一个命名为tag名的文件，值是此次提交的Hash值。 HEAD新建分支的时候，Git是怎么知道我们当前是在哪个分支的，Git又是如何实现分支切换的呢？答案就在HEAD这个文件中。 123456$ cat .git/HEAD ref: refs/heads/master$ git checkout test Switched to branch 'test'$ cat .git/HEAD ref: refs/heads/test 很明显，HEAD文件存储的就是我们当前分支的引用，当我们切换分支后再次进行提交操作时，Git就会读取HEAD对应引用的值，作为此次commit的parent。我们也可以通过symbolic-ref命令手动设置HEAD的值，但是不能设置refs以外的形式。 Packfiles到这里我们在文章开头所说的重点关注的目录和文件都介绍完毕了。但是作为一个文件系统，还存在一个问题，那就是空间。前文介绍过，当文件修改后进行提交时，Git会创建一份新的快照。这样长久下去，必定会占用很大的存储空间。而比较古老的版本的价值已经不大，所以要想办法清理出足够的空间供用户使用。 好消息是，Git拥有自己的gc（垃圾回收）方法。当仓库中有太多松散对象时，Git会调用git gc命令（当然我们也可以手动调用这个命令），将这些对象进行打包。打包后会出现两个新文件：一个idx索引文件和一个pack文件。索引文件包含了packfile的偏移信息，可以快速定位到文件。打包后，每个文件最新的版本的对象存的是完整的文件内容。而之前的版本只保存差异。这样就达到了压缩空间的目的。 Ending本文只介绍了Git的原理，如果对Git基本操作不熟悉的话，可以看看Pro Git。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo!]]></title>
    <url>%2F2018%2F08%2F05%2FHello-Hexo%2F</url>
    <content type="text"></content>
  </entry>
</search>
