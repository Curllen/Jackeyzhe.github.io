<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[送给你的算法敲门砖]]></title>
    <url>%2F2018%2F09%2F12%2F%E9%80%81%E7%BB%99%E4%BD%A0%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B2%E9%97%A8%E7%A0%96%2F</url>
    <content type="text"><![CDATA[在学校的时候老师一直跟我们强调算法的重要性，我和大多数同学一样不以为然，觉得学起来又难又枯燥。直到开始找工作以后，被各种算法面试题打击得体无完肤的时候，才算明白算法的重要性。 近年来，人工智能、区块链、大数据等概念非常火热，特别是AlphaGo之后，各大公司也都在积极开展人工智能领域的相关业务，而其中算法工程师这个职位更是供不应求，最近在网上见到好多人说要转算法工程师，不管是学医的、学法律的、学建筑的甚至是学经济的，都有做算法工程师的想法。可以说已经达到了人人转算法的地步了，那么为什么大家都想做算法工程师呢？我们先来看一组数据。 首先是人工智能类岗位的招聘需求 可以看到算法工程师的需求遥遥领先，需求大，机会就多，大家也就都愿意去尝试。但是只是这个原因似乎还不足以吸引这么多人去学算法。我们再来看一下互联网高薪清单 其中，很大一部分都是算法工程师，我们都知道最近几年互联网行业的薪资已经超过了曾经的“高富帅”金融行业。而算法工程师在互联网中又是高薪岗位，这个吸引力可想而知，毕竟没有谁会跟钱过不去。 上面说的都是国内的情形，在国外，大公司更是注重算法，据说面试Google的Android工程师的时候，会问几道特别难的算法题，而只要这几道题你答得好，Google甚至不在乎你究竟有没有做过Android，因为在他们看来，这么难的算法题都能学会，那么学习Android的技术根本不在话下。 总得来说，算法可以被称为大公司的敲门砖，说到这，有的人可能已经等不及了，算法是大公司的敲门砖这件事我已经知道了，那你说的算法的敲门砖到底是什么啊？ 其实，今天要推荐的是一个算法学习的网站，对于算法初学者，可能脑子里还不能很好的理清每个算法究竟是怎么一回事，或者说算法的工作原理到底什么样的。这个网站就是将算法可视化，把它的工作原理摆在你面前。 可以看到这里有很多算法和数据结构，包括排序算法、链表、Hash表、二叉搜索树等等。可以说应有尽有，只要你想学，就可以直接搜索相关的算法。点进去之后，会有相关的提示，然后就可以观看相关算法的工作视频了。这对于我们理解算法非常有帮助，把算法做到可视化，并且为你演示每一步如何工作，侧边栏还有相应的讲解。 总之，这个网站对于初学算法的同学来说算是一个非常好用的敲门砖了。这个网站的地址是： https://visualgo.net/ 建议大家最好看英文的，因为中文的翻译还是有些问题。可能在学习过程中造成一定的困惑。 最后，希望大家不要像我一样从入门到放弃，坚持下去，年薪百万不是梦。]]></content>
      <tags>
        <tag>瞎扯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ModelMapper的一次踩坑经历]]></title>
    <url>%2F2018%2F09%2F11%2F%E4%BD%BF%E7%94%A8ModelMapper%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[在实际项目中，我们常常需要把两个相似的对象相互转换，其目的是在对外提供数据时需要将一部分敏感数据（例如：密码、加密token等）隐藏起来。最普通的方法是，新建一个对象，将需要的值逐个set进去。如果有多组需要这样转换的对象，那么就需要做很多只是get/set这样无意义的工作。 在这样的背景下，ModelMapper诞生了，它是一个简单、高效、智能的对象映射工具。它的使用非常简单，首先添加maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.modelmapper&lt;/groupId&gt; &lt;artifactId&gt;modelmapper&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 然后就可以直接new出一个ModelMapper对象，并且调用其map方法将指定对象的值映射到另一个对象上了。 使用方法今天不做过多介绍，大家可以自行Google，找到ModelMapper的相关文档进行学习。今天要分享的时前几天无意间踩到的一个坑。我有两个类，PostDO和PostVO（这里只截取了部分字段，因此两个类的含义也不做解释了）： 123456public class PostDO &#123; private Long id; private String commentId; private Long postId; private int likeNum;&#125; 12345public class PostVO &#123; private Long id; private boolean like; private int likeNum;&#125; 在一个方法中，我试图将PostDO的一个对象映射到PostVO，因此我进行如下操作： 12345678public class Application &#123; public static void main(String[] args) &#123; ModelMapper modelMapper = new ModelMapper(); PostDO postDO = PostDO.builder().id(3L).likeNum(0).build(); PostVO postVO = modelMapper.map(postDO, PostVO.class); System.out.println(postVO); &#125;&#125; 执行结果是这样的： 1PostVO(id=3, like=false, likeNum=0) 无异常，项目中likeNum字段的值是随着项目的进行递增的。当likeNum增加到2时，异常出现了： 1234567891011121314151617181920212223242526Exception in thread "main" org.modelmapper.MappingException: ModelMapper mapping errors:1) Converter org.modelmapper.internal.converter.BooleanConverter@497470ed failed to convert int to boolean.1 error at org.modelmapper.internal.Errors.throwMappingExceptionIfErrorsExist(Errors.java:380) at org.modelmapper.internal.MappingEngineImpl.map(MappingEngineImpl.java:79) at org.modelmapper.ModelMapper.mapInternal(ModelMapper.java:554) at org.modelmapper.ModelMapper.map(ModelMapper.java:387) at Application.main(Application.java:7)Caused by: org.modelmapper.MappingException: ModelMapper mapping errors:1) Error mapping 2 to boolean1 error at org.modelmapper.internal.Errors.toMappingException(Errors.java:258) at org.modelmapper.internal.converter.BooleanConverter.convert(BooleanConverter.java:49) at org.modelmapper.internal.converter.BooleanConverter.convert(BooleanConverter.java:27) at org.modelmapper.internal.MappingEngineImpl.convert(MappingEngineImpl.java:298) at org.modelmapper.internal.MappingEngineImpl.map(MappingEngineImpl.java:108) at org.modelmapper.internal.MappingEngineImpl.setDestinationValue(MappingEngineImpl.java:238) at org.modelmapper.internal.MappingEngineImpl.propertyMap(MappingEngineImpl.java:184) at org.modelmapper.internal.MappingEngineImpl.typeMap(MappingEngineImpl.java:148) at org.modelmapper.internal.MappingEngineImpl.map(MappingEngineImpl.java:113) at org.modelmapper.internal.MappingEngineImpl.map(MappingEngineImpl.java:70) ... 3 more 提示int类型不能转换成boolean型，很明显。ModelMapper是将like字段映射到likeNum了。那么ModelMapper究竟是怎样进行映射的呢，我们一起来看一下ModelMapper的源码。 ModelMapper利用反射机制，获取到目标类的字段，并生成期望匹配的键值对，类似于这样。 接着对这些键值对进行遍历，逐个寻找源类中可以匹配的字段。首先会根据目标字段判断是否存在对应的映射， 123456Mapping existingMapping = this.typeMap.mappingFor(destPath);if (existingMapping == null) &#123; this.matchSource(this.sourceTypeInfo, mutator); this.propertyNameInfo.clearSource(); this.sourceTypes.clear();&#125; 如果不存在，就调用matchSource方法，在源类中根据匹配规则寻找可以匹配的字段。匹配过程中，首先会判断目标字段的类型是否在类型列表中存在，如果存在，则可以根据名称，加入匹配的mappings中。如果不存在，则需要判断converterStore中是否存在能够应用于该字段的转换器。 12345678910111213141516171819202122232425262728293031323334353637383940if (this.destinationTypes.contains(destinationMutator.getType())) &#123; this.mappings.add(new PropertyMappingImpl(this.propertyNameInfo.getSourceProperties(), this.propertyNameInfo.getDestinationProperties(), true));&#125; else &#123; TypeMap&lt;?, ?&gt; propertyTypeMap = this.typeMapStore.get(accessor.getType(), destinationMutator.getType(), (String)null); PropertyMappingImpl mapping = null; if (propertyTypeMap != null) &#123; Converter&lt;?, ?&gt; propertyConverter = propertyTypeMap.getConverter(); if (propertyConverter == null) &#123; this.mergeMappings(propertyTypeMap); &#125; else &#123; this.mappings.add(new PropertyMappingImpl(this.propertyNameInfo.getSourceProperties(), this.propertyNameInfo.getDestinationProperties(), propertyTypeMap.getProvider(), propertyConverter)); &#125; doneMatching = this.matchingStrategy.isExact(); &#125; else &#123; Iterator var9 = this.converterStore.getConverters().iterator(); while(var9.hasNext()) &#123; ConditionalConverter&lt;?, ?&gt; converter = (ConditionalConverter)var9.next(); MatchResult matchResult = converter.match(accessor.getType(), destinationMutator.getType()); if (!MatchResult.NONE.equals(matchResult)) &#123; mapping = new PropertyMappingImpl(this.propertyNameInfo.getSourceProperties(), this.propertyNameInfo.getDestinationProperties(), false); if (MatchResult.FULL.equals(matchResult)) &#123; this.mappings.add(mapping); doneMatching = this.matchingStrategy.isExact(); break; &#125; if (!this.configuration.isFullTypeMatchingRequired()) &#123; this.partiallyMatchedMappings.add(mapping); break; &#125; &#125; &#125; &#125; if (mapping == null) &#123; this.intermediateMappings.put(accessor, new PropertyMappingImpl(this.propertyNameInfo.getSourceProperties(), this.propertyNameInfo.getDestinationProperties(), false)); &#125;&#125; 默认的转换器有11中： 找到对应的converter后，converter的map方法返回一个MatchResult，MatchResult有三种结果：FULL、PARTIAL和NONE（即全部匹配，部分匹配和不匹配）。注意，这里有一个部分匹配，也就是我所踩到的坑，在对like进行匹配是，likeNum就被定义为部分匹配。因此，当likeNum大于2时，就不能被转换成boolean类型。 这里解决方法有两种，一种是在设置中，规定必须字段名完全匹配；另一种就是将匹配策略定义为严格。 设置方法如下： 12modelMapper.getConfiguration().setFullTypeMatchingRequired(true);modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT); 到这里，ModelMapper会选出较为合适的源字段，但是如果匹配要求不高的话，ModelMapper可能会筛选出多个符合条件的字段，因此，还需要进一步过滤。 123456789PropertyMappingImpl mapping;if (this.mappings.size() == 1) &#123; mapping = (PropertyMappingImpl)this.mappings.get(0);&#125; else &#123; mapping = this.disambiguateMappings(); if (mapping == null &amp;&amp; !this.configuration.isAmbiguityIgnored()) &#123; this.errors.ambiguousDestination(this.mappings); &#125;&#125; 这里我们看到，如果匹配到的结果只有1个，那么就返回这个结果；如果有多个，则会调用disambiguateMappings方法，去掉有歧义的结果。我们来看一下这个方法。 123456789101112131415161718192021222324private PropertyMappingImpl disambiguateMappings() &#123; List&lt;ImplicitMappingBuilder.WeightPropertyMappingImpl&gt; weightMappings = new ArrayList(this.mappings.size()); Iterator var2 = this.mappings.iterator(); while(var2.hasNext()) &#123; PropertyMappingImpl mapping = (PropertyMappingImpl)var2.next(); ImplicitMappingBuilder.SourceTokensMatcher matcher = this.createSourceTokensMatcher(mapping); ImplicitMappingBuilder.DestTokenIterator destTokenIterator = new ImplicitMappingBuilder.DestTokenIterator(mapping); while(destTokenIterator.hasNext()) &#123; matcher.match(destTokenIterator.next()); &#125; double matchRatio = (double)matcher.matches() / ((double)matcher.total() + (double)destTokenIterator.total()); weightMappings.add(new ImplicitMappingBuilder.WeightPropertyMappingImpl(mapping, matchRatio)); &#125; Collections.sort(weightMappings); if (((ImplicitMappingBuilder.WeightPropertyMappingImpl)weightMappings.get(0)).ratio == ((ImplicitMappingBuilder.WeightPropertyMappingImpl)weightMappings.get(1)).ratio) &#123; return null; &#125; else &#123; return ((ImplicitMappingBuilder.WeightPropertyMappingImpl)weightMappings.get(0)).mapping; &#125;&#125; ModelMapper定义了一个权重，来判断源字段是否有歧义，这里根据驼峰式的规则（也可以设置为下划线），将源和目标字段名称进行拆分，根据 匹配数量/源token数+目标token数，得到一个匹配的比率，比率越大，说明匹配度越高。最终取得匹配权重最大的那个字段。其他字段被认为是有歧义的。 截至目前，默认的ModelMapper的map方法的工作原理已经介绍完了，中间可能有些遗漏的细节，或者哪里有说的不明白的地方，欢迎大家和我一起讨论。大家在用到ModelMapper时一定要注意字段名，如果有相近的字段名，必须认真核对匹配是否正确，必要时就采用严格匹配策略。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（八）：迭代的原则]]></title>
    <url>%2F2018%2F09%2F08%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[我们都知道，一个软件的维护成本往往要高于其研发成本。在维护过程中，我们的代码需要不断的进行迭代。迭代的目的有两个：修复bug和增加新特性。但是迭代也会带来一系列新的问题，比如新的bug，或者是破坏代码的整洁性。这里我们从保持代码整洁性的角度来讨论一下迭代的几个原则。 运行所有测试没错，首先的要说的还是测试，我们要在每次迭代代码之后，运行所有的测试，如有必要，也要编写新的测试。我们要编写尽量简单的测试，简单的测试会驱使我们降低类与类之间的耦合度。如果还不了解如何编写单元测试，可以参考一下旧文代码洁癖系列（七）：单元测试的地位。良好的测试不但是代码质量的保证，同时也是良好设计的引导。 不要重复“造轮子”记得我的leader曾经告诉过我：写每一行代码之前，要先思考一下有没有必要写这行代码。在实现一个功能之前，先确认一下这个功能是否已经被实现了。永远不要重复“造轮子”。但是，当我们进行一定的共性抽取时，可能已经违反了SRP原则（Single Responsibility Principle）。因此，抽取出的方法可能需要放在其他类中。 可读代码是程序员之间的交流工具，要想获得其他程序员的尊重，必须使你的代码具备可读性。这也是我们要保持代码整洁的原因。如何保证代码的可读性呢？首先需要的就是有意义的命名，关于命名规则，可以参考代码洁癖系列（二）：命名的艺术这篇文章，其次就是通过测试用例让别人了解你的代码。 尽可能少的类和方法在代码洁癖系列（三）：整洁的类和函数一文中，我们说过类和函数都应该尽量短小。有人问了，为了类和函数都足够短小，我要把代码拆分成许多的类吗？这里需要说明一下，在这方面，我们并不需要追求极致。应该根据实际情况，合理的拆分。所以，也要尽量减少类和方法，这可能与“类和函数应该短小”这一原则相矛盾。这需要工程师自己去衡量了，首先要保证“类和函数应该短小”，其次才是尽可能减少类和方法。 结束语到这里，”代码洁癖系列“的文章要告一段落了，希望大家在写代码的时候可以多思考，保证自己代码的整洁性。文章有什么问题，或者我有哪些遗漏的地方，大家可以通过去我的微信公众号后台留言和我讨论。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用的工具，有趣的人]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%AE%9E%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[1998年的9月4日，拉里·佩奇和谢尔盖·布林将Google带到这个世界。就在前几天，Google刚刚过了20岁生日。经过20年的发展，Google早已不是当初的小作坊了，而是发展成为被大家公认的全球最大的搜索引擎公司。20年间，Google不仅在搜索技术上表现颇为出色，在大数据、云计算、AI等各个方面都有着巨大的贡献。 我们都知道，如今世界已经从互联网时代走向大数据时代。数据几乎已经成为各个互联网公司的命脉，数据分析师这一职位也应运而生（虽然我本人不是数据分析师），但是我对数据分析很感兴趣。刚刚过完20岁生日的Google这次可以算是给数据分析师和数据分析爱好者们送上了一份大礼（果然是大公司，自己过生日还给我们送礼）——一款叫做Google Dataset Search的搜索引擎。它是一款专门用来搜索数据集的搜索引擎，搜索结果中包括了数据集的创建者，发布时间，数据集的收集方式，数据集的使用条款以及对数据集的描述。 还记得我当初自学大数据知识的时候，每每到了想要亲自动手试一试的时候，总是为找不到合适的数据集而苦恼。最后，我决定自学Python爬虫，想要什么数据都自己动手爬。然而，这种工作还是挺繁琐的，也许对我这种自学的爱好者无所谓，反而还多掌握一门技术。但对于专门从事数据科学工作的人来说可能会觉得很痛苦。 随着Google Dataset Search的诞生，这种“巧妇难为无米之炊”的尴尬终于一去不复返了。现在你想要什么数据集都可以直接搜索，简直不要太方便。 这个网站的地址是： https://toolbox.google.com/datasetsearch 可以访问的同学可以上去体验一下，目前还是Beta版，没办法访问的同学，看看这个界面先过过瘾吧。 以上就是今天要介绍的实用的工具。下面再来介绍一个有趣的人，同样是和DataSet Search有关。 要介绍的这个人呢，作为程序员一定很熟悉，就是Linux之父Linus Torvalds。怀着对大神的崇敬之情，我今天用Dataset Search搜索了一下Linus。结果果然没有令我失望，先来展示一下搜素结果。 第一条是Linus Torvalds Rants，可以理解为Linus的粗话（这是什么鬼？黑人问号脸）。 我们注意到数据集的描述为Linus2012年到2015年邮件的粗话合集。到这里有些怀疑这个数据集的真实性，不过对大神崇敬之情驱动着我点了进去，看看大神是怎么骂人的， 这是数据集的部分截图，链接也都是可以直接访问的。 总之，Linus大神说话还是挺文明的，这种做法也非常有Linus的风格。（这里顺便提一下，Linus曾经在Linux内核代码中记录了女儿的生日）怎么样，是不是今天才发现原来Linus是如此有趣的人？ 最后，国内某公司CEO说要“再”次击败Google，我觉得他们首先还是要多做些像这样有意义的事吧。]]></content>
      <tags>
        <tag>瞎扯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（七）：单元测试的地位]]></title>
    <url>%2F2018%2F09%2F04%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9C%B0%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[在许多程序员眼中，单元测试似乎是可有可无的，觉得这应该是测试人员的工作。实际上，测试代码和生成代码同样重要。我们不但需要测试代码，而且需要的是整洁的测试代码。 测试为什么要整洁我们对待测试代码需要像对待生产代码一样，写之前需要进行严谨的思考、详细的设计。这里分享一下我自己的学习编程的一些经历。 没有单元测试刚毕业的时候，我的代码可以说是年少轻狂，总是对自己充满自信。根本就不写单元测试，写完之后自测也是随意的点两下就算自测通过了。代码提交测试后，恐怖的事情就出现了，铺天盖地的bug向我袭来。每天工作有一半以上的时间是在和测试同事沟通，其余的时间是在改bug。本来1天的工作可能需要3天才能完成。当我意识到这样做完全是费力不讨好的时候，我决心每次写完代码之后，要写一段单元测试，保证单元测试通过后再提交。 随意的单元测试在开始写单元测试之后，我的工作效率提高了很多，下班都比原来早了。感觉写单元测试是一个无比正确的决定。随着项目的进行，中间处理过几次紧急的bug fix，当时就没有顾上去写单元测试。然而，当我又一次完成一个新的feature的时候，像往常一样开始跑单元测试，结果是：Failed！就是因为之前的改动导致的。由于手里还有其他比较紧急的工作，单元测试又被放下了。就这样，我又回到了没有单元测试的工作状态。 现在的我已经不像当初那样盲目的自信了，没有单元测试的代码让我感到恐慌。 决心重构单元测试曾经有一段可用的单元测试放在我面前，但我没有珍惜，直到失去才追悔莫及。这次我决心重建单元测试，不但要重建，还要写一段好的单元测试。吸取上次的教训，要使我的单元测试可扩展，可维护。把一些公共的方法抽取出来，将不同概念的测试进行拆分。做到“每个概念一个测试”，测试中需要使用断言判断是否成功，而不是人为查看日志。每个测试都要包含构造-操作-检验三个环节，这三个环节要定义清楚。 这样一来，我就有了一套整洁的单元测试，后来修改代码后，单元测试可以方便的进行扩展和复用，工作效率再次提升。 整洁测试的规则整洁测试需要遵循F.I.R.S.T规则。什么是F.I.R.S.T规则呢？ 快速（Fast）测试应该足够快，如果测试一次需要等待很长时间，没有人愿意频繁的运行测试，也就没办法快速发现问题。久而久之，我们又会失去测试…… 独立（Independent）测试之间应该相互独立，一个测试的失败不应该影响其他的测试，否则就会导致每次测试出现一大堆问题，我们每次只能解决最上级的测试暴露出来的问题，下级测试需要再次测试才行。这就会大大降低工作效率。 可重复（Repeatable）测试应该在各种环境中可以重复执行，不论是你的本地环境，测试环境还是生产环境。测试都应该能够跑通。这样才能保证线上的质量，测试也才有意义。 自足验证（Self-Validating）测试应该有布尔值输出（最好使用断言），我们不应该通过查看日志来判断测试是否通过，更不应该通过人为比较两个文本是否相同来判断测试是否通过。这样不但失去了测试的准确性，也浪费了我们自己的时间。 及时（Timely）测试应该及时编写，在设计生产代码的同时就应该将测试一并设计好，不然的话，当你写好生产代码，也许会因为某些代码难以测试而放弃。 结语总结一下今天讨论的内容，我们需要整洁的单元测试，它的地位与生产代码一样，需要我们认真设计。设计测试的时候需要遵循F.I.R.S.T原则。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（六）：处理错误]]></title>
    <url>%2F2018%2F09%2F03%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[程序运行过程中，有些错误是不可避免的，而如何使程序在出现错误时代码仍然正常工作就成了程序员的日常工作之一。那么处理错误和代码整洁有什么关系呢？ 前面我们提到过，try-catch代码块会破坏代码的结构。但是，我们在处理错误时又不得不使用try-catch代码块，这样才能让我们的程序保持健壮。那么如何兼顾整洁和健壮呢，这就是我们今天要讨论的内容。 不要使用返回码在上古时期，很多语言还都不支持异常，程序员们只能约定好返回的错误码，通过不同的错误码对代码进行错误处理。这么做需要调用者在调用方法后马上判断返回值来决定是否需要处理错误。而这一步骤往往被遗忘，就会导致程序出现不可预估的问题。所以，现在我们有了throw和try-catch这样的“热武器”，就不要再用错误码这样的“冷兵器”了。不然很容易就会被别人给秒杀的。 try-catch-finally相信大家都很熟悉，不熟悉的话，可以前往本站达成合作的各大搜索引擎进行搜索，保证有答案。 异常抛出的层级我们不希望程序中充满了try-catch代码块，这样会使程序的可读性变差。因此，我们要适当的使用throw语句，将异常抛出。交给上一层去处理。但是，如果只由最顶层的代码去处理异常，整个程序看上去是会整洁一些，但当我们需要修改某个底层代码抛出的异常时会发生什么呢？我们需要找到往上抛的每一个方法去修改它的签名，抛出新的异常，并重新发布。这会使我们的工作量增加好几倍。所以，我们的异常最好在本层进行统一处理，或者在抛出后的上一层就进行处理。 说明发生异常的环境在Java中，系统异常通常会给出调用栈，便于我们进行问题的定位和调试。对于我们自己抛出的异常，也应该给出异常发生的环境，例如列出调用栈，给出请求参数等等。 远离null值我们在读、写代码时，一定有被好多层的空指针判断折磨的经历。一不小心漏掉一个判断，那么程序就会出现空指针异常，这个异常要么被上层的catch捕获，要么直接抛出。很明显，这两种结果都不是我们想要的。怎么远离空指针异常呢？ 首先，代码的返回值不要返回null。可以选择直接抛出一个异常，或者返回一个特定的值，比如空对象等。 其次，代码调用时，参数不要传null，因为一旦传null，那么在方法体中就需要对这个参数进行非空判断。而目前还没有什么好的方法可以简单高效的处理参数外部传来的null，只能使用if判断。因此希望大家在调用别的方法时尽量不要传入null。 小结本文的主要目的是使我们的代码兼顾整洁性和健壮性。这就需要我们将错误处理独立于主逻辑之外，使错误就可以被单独处理，不但能够增强可读性，还能增强可维护性。最后得到的就是我们希望看到的整洁而健壮的代码。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（五）：外在的格式美]]></title>
    <url>%2F2018%2F08%2F31%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%A4%96%E5%9C%A8%E7%9A%84%E6%A0%BC%E5%BC%8F%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[我们在阅读一些优秀项目的源码时，一定会感叹他们代码的整洁和一致性。而作为第一印象，代码格式的整齐是让人能够继续阅读下去的动力。今天我们分别从垂直格式和横向格式两个方面来讨论代码的格式。修正格式的方法有：间隔、靠近和调整顺序。 垂直格式在垂直格式方面，我们要向报纸的排版学习。 首先有一个标题告诉你这栏新闻要讲什么，好让你知道是否要继续阅读下去。对应到代码中就是类的名字，我们要力求只通过名字就可以知道这个类要描述什么事情；然后，代码的第一段往往都交代了整个故事的概要，类似于代码中的接口，我们往往通过接口了解类中有哪些函数，每个函数都是干什么的。了解了这些之后，才会去读详细的内容。 newspaper code 标题 类名 第一段 接口 内容 方法体 此外，还需要注意的就是报纸的排版、段落和段落之间用空行做间隔。写代码也可以用同样的方式，例如，我们习惯于在包声明、导入声明和每个函数之间用空白行来分隔。我们直接拿代码来解释。 123456789101112131415161718192021222324252627282930313233343536373839package com.thoughtworks.selenium;import org.testng.ITestContext;import org.testng.ITestResult;import org.testng.Reporter;import org.testng.internal.IResultListener;import java.io.File;public class ScreenshotListener implements IResultListener &#123; File outputDirectory; Selenium selenium; public ScreenshotListener(File outputDirectory, Selenium selenium) &#123; this.outputDirectory = outputDirectory; this.selenium = selenium; &#125; public void onTestFailure(ITestResult result) &#123; Reporter.setCurrentTestResult(result); try &#123; outputDirectory.mkdirs(); File outFile = File.createTempFile("TEST-" + result.getName(), ".png", outputDirectory); outFile.delete(); selenium.captureScreenshot(outFile.getAbsolutePath()); Reporter.log("&lt;a href='" + outFile.getName() + "'&gt;screenshot&lt;/a&gt;"); &#125; catch (Exception e) &#123; e.printStackTrace(); Reporter.log("Couldn't create screenshot"); Reporter.log(e.getMessage()); &#125; Reporter.setCurrentTestResult(null); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.thoughtworks.selenium;import org.testng.ITestContext;import org.testng.ITestResult;import org.testng.Reporter;import org.testng.internal.IResultListener;import java.io.File;public class ScreenshotListener implements IResultListener &#123; File outputDirectory; Selenium selenium; public ScreenshotListener(File outputDirectory, Selenium selenium) &#123; this.outputDirectory = outputDirectory; this.selenium = selenium; &#125; public void onTestFailure(ITestResult result) &#123; Reporter.setCurrentTestResult(result); try &#123; outputDirectory.mkdirs(); File outFile = File.createTempFile("TEST-" + result.getName(), ".png", outputDirectory); outFile.delete(); selenium.captureScreenshot(outFile.getAbsolutePath()); Reporter.log("&lt;a href='" + outFile.getName() + "'&gt;screenshot&lt;/a&gt;"); &#125; catch (Exception e) &#123; e.printStackTrace(); Reporter.log("Couldn't create screenshot"); Reporter.log(e.getMessage()); &#125; Reporter.setCurrentTestResult(null); &#125;&#125; 是不是适当增加空白行就提高了代码的可读性呢，这里说的是适当增加空白行，并不代表随意增加。事实上，如果增加一些无意义的空白行反而会使代码的可读性变差。 我们习惯于使有关联的代码彼此靠近，无明显关联的代码相互分隔。因此我们不但需要使用空白行间隔代码，还要调整代码位置，把有关联的代码放在一起，通常我们把被调用的函数放在调用函数的下面。这样别人在读我们的代码的时候再也不用经历来回“跳跃”的痛苦了。 最后，我们通常把实体变量定义在类的顶部，这个只是我们Java程序员的习惯操作，如果突然在类的中间位置出现一个变量声明会让人觉得很奇怪。如果你想说，定义在中间是不想让定义位置和调用位置离太远，那么只能说明你的类定义出现了问题。建议你看一下旧文代码洁癖系列（三）：整洁的类和函数。 横向格式介绍完垂直格式，紧接着自然要来介绍一下它的兄弟，横向格式。或许你会问为什么不叫水平格式，我的回答是：也可以叫水平格式，只要你喜欢。横向格式也是需要间隔和靠近的，这里的间隔主要是为了起到强调的效果。举个例子。 1int lineSize = line.length(); 这里等号两边的空格分别是为了强调左右两边的元素。横向格式另一个比较重要的元素就是缩进，Java程序对缩进没有强制性要求，而Python程序对缩进的要求非常严格，稍有不慎，执行的结果就会不同。但是Java程序员也要注意缩进，因为我们的代码是层级关系，而缩进可以帮我们快速理清层级关系。 最后，横向代码格式对每行代码长度是有要求的，如果代码过长，那么在阅读的时候就需要左右滑动，而这个操作其实是不受人喜欢的。虽然现在代码编辑器可显示的长度变大了，但我们还是习惯每行代码最多100个字符。 团队的规则每一个优秀的团队都已一套属于自己的代码格式要求，有些是特定的，有些是使用公共的。我们team所用的代码规范就是Google的代码规范，阿里的代码规范也是比较被大家认可的。这里给大家一个小福利，在我的公众号后台回复【代码规范】，就可以获得一份阿里的Java开发手册。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（四）：可忽略的注释]]></title>
    <url>%2F2018%2F08%2F30%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8F%AF%E5%BF%BD%E7%95%A5%E7%9A%84%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[刚开始学编程的时候，老师就告诉我们，注释很重要，但是一直到现在，也没有人真正告诉过我要怎么写注释。还有很多人甚至干脆不写注释。所以今天想聊一下到底如何写注释。 提到注释就让我想起一个段子：两个程序员去饭店吃饭，点菜的时候程序员甲说：我要吃宫保鸡丁，程序员乙就帮他记。 1宫保鸡丁 然后程序员甲又说：我不想吃宫保鸡丁了，换成地三鲜吧。程序员乙就说好的，然后又帮他记上了。 12//宫保鸡丁地三鲜 这个段子也从侧面反映了程序员们习惯性忽略注释的事实。段子讲完了，下面插播一些正文。 注释不能拯救糟糕的代码首先，我想说的可能和大多数人的观点相左：尽量少用注释！没错，尽量少用。因为注释是会骗人的，而且时间越长的注释越容易骗人，因为大部分人在修改代码的时候都不会去修改注释。少写注释，尽量用代码去描述你要做什么。当你要写注释的时候，就要思考一下，别人为什么不能通过代码理解你想表达什么。这时你需要尝试修改代码，来达到上述目的。 123// Check to see if the employee is eligible for full benefitsif (employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65) 看一下这段代码，如果只看代码，可以理解它要表达什么吗？ 1if (employee.isEligibleForFUllBenefits()) 花上点时间，把代码改成这样，是不是不用注释也可以读懂了？ 我们这里说尽量少使用注释，并不是完全不用注释，在某些情况下，我们需要注释。那么什么样的注释才算是好的注释呢？ 法律信息有时，公司代码规范会要求注明版权和著作权。那么我们就应该将这些信息放到源文件的开头位置。 提供信息的注释12// Returns an instance of the Responder being tested.protected abstract Responder responderInstance() 这样的注释就是不错的注释，给读者提供了返回值的信息，不过，如果我们把函数命名为responderBeingTested，那么这个注释也就显得多余了。 阐释可以用注释把某些难以理解的参数或返回值翻译成可以理解的形式。当前，前提是如果这些代码你无法修改，比如参数或返回值是标准库的一部分。这时阐释就显得很有用。举过来一个栗子。 123assertTrue(a.compareTo(a) == 0); // a == aassertTrue(a.compareTo(b) != 0); // a != bassertTrue(a.compareTo(b) == -1); // a &lt; b 不过这样的阐释也有缺点，那就是它有可能是不正确的，我们需要小心确认其正确性。如果缺失正确性，那么这样的阐释只会起到负面作用。 TODO注释TODO注释是比较常用的注释，可以在代码里添加工作列表，例如，对一个空实现函数添加TODO注释，就可以解释这里为什么是空实现，以及以后要实现什么。 公共API的Javadoc这个也许最令人欣赏的注释习惯了。不过目前我们通常用swagger来代替注释。对swagger感兴趣的童鞋可以戳这里。 所谓见贤思齐焉，见不贤而内自省也。看完了好的注释，就要想想怎么才能写出好的注释；接下来再来看看坏的注释，看的同时需要多反省自己，尽量避免写出坏的注释。 自说自话写的东西只有自己能看懂，别人都不明白要表达什么。如果读代码时连注释都看不明白，还有人想看下去吗。 日志式注释几乎把代码的每次修改记录都写到注释里，也许在那个没有代码版本控制工具的远古时代，这么做还有一定的意义。但是现在我们拥有很多健壮的代码版本控制工具，这样的注释也就变得毫无意义。 在代码里加上自己的签名也是一样的道理，我们都可以通过代码版本控制工具查看具体的创建者和修改者，而不是只记住创建者。 注释掉代码也是一样，我们用版本控制工具可以轻松找回以前的代码，不需要的代码可以直接删掉，而不是留一个注释掉的代码放在那里。 废话注释12/** The day of the month. */private int dayOfMonth; 我不想多废话了…… 结语也许文中的观点和大多数人的思维相左，可能我的有些观点是错的，欢迎大家关注我的微信公众号，和我讨论注释究竟是否必要。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（三）：整洁的类和函数]]></title>
    <url>%2F2018%2F08%2F29%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%95%B4%E6%B4%81%E7%9A%84%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前面我们讨论了什么样的命名更能够让你赏心悦目，今天来讨论一下面向对象编程过程中最重要的环节，编写类和函数。我们仍然用Java来演示，什么样的类和函数才算是整洁的。 首先讨论函数，函数定义好了，类也就容易了。 短小相信大家在读代码的时候都会遇到过冗长的函数定义。没有的话可以私信我，我把原来写过的一段300+行的函数发给你，不过不要问我这个函数是做什么的，因为我也忘了，而且不想回顾。当然如果你足够耐心研究出来了，请教教我。 言归正传，为什么函数要短小呢，如何才能是自己的函数更加短小？第一个问题我也无法证明，只能告诉你短小的函数看起来更加清晰，更加容易理解。那怎么才能让函数变得更加短小呢？很简单，抽离方法。将一些代码抽离成另一个函数。什么样的长度才是合适的呢？我认为不必过于追求短。这里的长度我们可以以代码块的层来定义，对于下面这种代码相信任何人看了都会崩溃吧。 12345678910111213public void doSomething() &#123; for() &#123; ... while() &#123; ... if() &#123; ... &#125;else &#123; ... &#125; &#125; &#125;&#125; 所以每个函数中有一层或两层为最佳，每层代码块最好不超过3行。这是我认为最佳的函数长度，当然，这个也可以根据个人习惯稍作调整。 只做一件事如果说长度还可以根据个人习惯，那么“只做一件事”的要求应该是大家都应该遵守的公约了。如果一个函数中做了太多的事，那么代码阅读起来的难度将会成倍增加，而且文档书写难度同样增大。还有就是给其他代码调用造成不便。比如我定义了函数A做了1和2两件事，函数B想做2和3，怎么办？这时B只能再写一遍A中做2的代码。而这样就会有大量重复代码出现，不但增加工作量，对日后的维护工作也造成很大的负担。而把1和2分别定义为函数C和函数D的话，只需要在AB中分别调用就可以了。 命名这里不多解释，函数的命名需要具有描述意义，函数越短也就越容易描述。 函数参数参数数量越少越好（这个我目前也没有做到），究其原因，首先是读代码时每次都要搞清楚每个参数的意义，所以自然越少越好。另一方面就是为测试的同事提供方便，如果有多个函数，测试的同学就需要考虑更多的测试用例对其进行覆盖。如果一个函数有3个以上的参数，那测试的同学可能想要打人了。 使用异常代替返回错误码这样就可以将Try/catch代码块抽离出来，因为Try/catch代码块影响了正常程序的流程，看起来很丑陋。 函数的主要规则就是这些，那么如何才能写出这样的函数呢？其实没有什么特别的技巧，就是记住这些规则，在每次写完代码之后再斟酌一番，对代码进行反复的打磨，修改不合适的命名，抽离冗长的函数。久而久之，你的代码一定会被人称赞的。 说完函数再来说一下如何写好一个类。 还是短小没错，类也应该短小，不过这里短小的定义和函数短小的定义稍有不同，我们通常以“权责”来衡量。先看下面这个类。 1234567public class SuperDashboard extends JFrame implements MetaDataUser &#123; public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber()&#125; 这个类只提供了5个方法，应该不算长，但是我要说，它仍然不满足我们“短小”的条件，原因就是违反了单一权责原则。单一权责指的是一个类只描述一类事。上面这个类有对最后焦点组件的读写方法，还有获取版本号和序列号的方法。只要我们描述一个类时，用到了类似于“还有”这样的字眼时，那么这个类就违反了单一权责原则，就需要对其中的方法进行抽离。 为了修改而组织大多数系统都会进行持续的迭代，而这也意味着我们需要不断对代码进行修改。而修改代码往往伴随着风险。所以，我们需要做的就是，修改一个方法时，不对其他方法造成影响。当我们开始修改时，就要评估好影响，然后将方法进行抽象，拆分。力求做到每次修改都不影响其他类（即降低耦合）。 对于写好一个类，总结来说就是“高内聚，低耦合”。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（二）：命名的艺术]]></title>
    <url>%2F2018%2F08%2F27%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%91%BD%E5%90%8D%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[不知道大家还记不记得《家有儿女》里有这么一段经典台词：“我叫夏雪”，“我叫夏雨”，“我叫夏冰雹”。 刘星自己给自己起的名字承包了我所有笑点。但仔细想想这名字取的竟然还挺不错，不但有意义，还和夏雨夏雪的名字相呼应。 回到主题，在我们的代码里，命名是随处可见的，比如给包命名，给类命名，方法名，参数名，变量名等等。那么什么样的命名才算是好的命名呢。这就是我们今天要讨论的。 名副其实首先还是要强调这一点，我读过的糟糕的代码有一个共同的特点，那就是代码中存在大量随意的，无意义的命名。比如：表示消耗多少小时的变量命名为h，同作用域中还有一个想要表示“小时”相关的变量直接命名为h1，一个List类型的变量就命名为list。读这种代码不会令人开心，同时写这种代码的程序员的人身安全是无法保证的。 123456789public List&lt;String&gt; getThem() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String key : keys) &#123; if (theMap.get(key) == 1) &#123; list.add(key); &#125; &#125; return list;&#125; 读一下上面这段代码，能看出有什么问题吗？或者说看完有人明白这段代码要做什么吗？ 我先来说一下我的问题： getThem是get什么？ list里存的是什么 keys指的是什么，为什么遍历它 常量”1“的意义是什么 这几个问题可能只有写这段代码的人才能解释（没错，就是我写的）。所以我来给大家解释一下，不过我不想一一回答上面的问题，我把代码重写一遍，看看还会不会有这样的问题。 123456789public List&lt;String&gt; getPaidOrderIds() &#123; List&lt;String&gt; paidOrderIds = new ArrayList&lt;&gt;(); for (String orderId : orderIds) &#123; if (orderStatus.get(orderId) == OrderConstatn.PAID) &#123; paidOrderIds.add(orderId); &#125; &#125; return paidOrderIds;&#125; 怎么样，上面的问题都清楚了吗，如果不清楚可以私下和我联系，我会给你推荐一个非常好的英语学习软件。 这就是名副其实的重要性。 避免误导命名过程中要注意的第二点就是要避免名称对别人产生误导，例如上面代码中paidOrderIds这个变量，如果我们命名成paidOrderIdList呢，看起来似乎没什么问题，但是如果这个变量是Set类型或者其他类型呢？命名为xxxList还合适吗，别人读代码的时候会下意识的认为这是个List类型的变量（尽量避免名称中出现类型的名字）。 另一点容易产生误导的是数字和字母相像的情况，比如，我命名一个变量叫做O1，在编辑器里就很难分辨是O1还是01，如果我写一个这样的表达式 1O0 = l1; 估计别人会以为我发明了什么新的语言吧。 第三点是要避免区别较小的两个名称，比如XYZContinentController和XYZCentinentController这样的命名，对于读代码的人来说简直就是灾难，对于写代码的人来说也存在很大的风险。（为什么不是灾难？因为大部分人都是Ctrl+C/Ctrl+V的，这样就减小一些出错的几率。看来善用Ctrl+C/Ctrl+V还是很有必要的） 做有意义的区分编译器要求我们在同一个区域内不能重复命名。那么有的程序员就会写出a1,a2,a3……这样的命名，这看起来很烂，谁也不知道它们有什么区别。再举过来一个栗子，一个包中有两个类，Product和ProductInfo，这时让你查一下商品名称，你知道要去哪个类里找吗？事实证明，这样的命名与a1,a2,a3之流别无二致。 既然要做区分，为什么不做些有意义的区分呢，一个类叫做Product，表示商品信息，另一个叫做ProductStocks表示商品的库存信息。这样是不是更清晰一点呢，当然，我这里只是举个栗子，实际上可能不需要这样定义。 别随意使用简写不要随意使用简写，除非是大家都知道的简写。比如美国的命名写成US，大家都可以理解，而如果generateCode写成genCode就令人费解了。 使用可以被搜索的名称像我们在一开始的那段代码，为什么要把常量“1”写成OrderConstatn.PAID，不仅是为了可读，也是为了可搜索，试想，如果你要找这段代码，去搜索数字1，会有多少结果？搜索PAID呢？亲自试过之后相信你会回来点赞的。 类名和方法名类名和方法名也要遵循上面的规范，除此之外，它们还有各自的规范： 类名不应该是动词，避免使用Data、Info这样的词汇。 方法名应该是动词，比如，saveXXX、deleteXXX 要专一假如你在不同的类中，分别定义了方法getXXX、fetchXXX和findXXX，我要调用的时候怎么知道某个类中应该使用哪种方法？所以，为什么不都用getXXX的形式呢？这样无论是对写代码的人还是对调用的人来说都是莫大的喜讯。 适当添加语境当你一些变量：firstName、lastName、street、houseNumber、city、state、zipcode。我们可以很轻易的判断出，他们组合在一起表示一个地址。那么把state单独拿出来呢？你还能知道它是什么意思吗？这时，我们可以把变量命名为addrState、addrFirstName……这样即便单独看某个变量，也会理解它要表达什么。当然更好的方法是定义一个名为Address的类，把这些变量放到类中，事实上我们也都是这样做的。 当然，有时候也不能添加一些无意义的语境。我们要开发一个“画图”的应用，那在每个类名前加Drawing可不是什么好主意。 结语命名并不能算是什么技术，而是一种写代码的习惯，但这种习惯有可能会决定你作为一名程序员给人的第一印象。所以，养成一个好的命名习惯，也是对自己形象的维护。同时还能让自己的生命安全更有保障（避免被同事……]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码洁癖系列（一）：什么是整洁代码]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%BB%A3%E7%A0%81%E6%B4%81%E7%99%96%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[作为一个代码洁癖患者，我最大的愿望就是世界和平……对不起，拿错剧本了，最大的愿望就是将对代码的洁癖传播给每一个人，净化所有的代码。这是一个宏大的愿望，但我会一直努力净化我所看到的每一行代码，并且希望能影响更多的人，让大家都写出整洁的代码。 在阅读本文之前，想先提两个问题： 你是程序员吗 你想成为更好的程序员吗 如果上面两个回答都是肯定的，那请你继续读下去，否则就可以直接关闭网页了。 什么是整洁代码相信有过一定工作经验的程序员都读过别人的代码，也一定看到过槽糕的代码，看到那些糟糕的代码时你是不是在想：这写的什么垃圾东西，读懂这段代码所花费的时间我都能把这个功能再实现一遍了。还有另一种情况：引用别人的代码时，为了能按时完成，不得不去适应别人的代码风格，跟着制造混乱。当混乱越来越多时，整个团队的生产力也越来越低，直到最后不得不把所有代码重新整理一遍，而这个工作里可想而知。 上面说的都是糟糕的代码所带来的影响。那么什么是整洁的代码呢？在我看来可以从两个方面定义整洁代码： 外在美 外观看起来优雅美观的代码会使人心情愉悦。其中主要体现在：代码所在的位置是否恰当，代码里是否有适当的注释，适当的缩进和空行以及没有重复代码等等。 内在美 外在美只是“看起来”使人心情愉悦，如果缺乏内在美，那么当别人真正开始读的时候，刚才愉悦的心情会在一瞬间烟消云散。而内在美则体现在：尽量少的API，代码之间的尽量少的依赖，干净利落的抽象和直截了当的控制语句等。 在理解了什么是整洁代码后，希望我们在写每一行代码之前都要思考一下，这行代码是否足够整洁，是否让人看了心情愉悦。 之后的一段时间，我也将会从以下几个方面和大家分享，如何写出整洁的代码。 有意义的命名什么是无意义的命名？如果代码中所有的变量名，函数名都是abcd之类的，相信你在看到这样一段代码的第一眼就已经失去了读下去的欲望了。也许有人觉得这太极端了，认为不会有人这样写代码。那么我们在考虑一下，我为一个变量命名为name，那么在没有前后语境的情况下，你能想象出这个变量是用来做什么的吗？是一个人的name还是一个物品的name，是firstName还是lastName？所以，有意义的命名对代码阅读是非常重要的。 如何定义类和函数如何定义相信大家都会，毕竟这是最基本的操作，那么怎么才能算是整洁的类和函数呢？ 要不要写注释大多数程序员都觉得写注释（文档）很麻烦，觉得自己的工作就是实现功能，自己写的代码自己能看懂就行。事实上真的是这样吗，他们真的能看懂自己三个月前写的代码吗？ 另一种程序员知道要写注释，但是他们写的注释都是诸如：“这是一个方法”、“这是一个循环”……这样的注释写出来真的有意义吗？ 如何排版这个属于外在美，第一印象很重要，第一眼看上去很好，才会继续看下去不是吗。 错误处理代码运行时的错误如何处理吗？全部抛出去，交个用户处理？全部catch住，隐藏起来不处理？这两种程序员相信都会被老板当成错误处理掉吧。 合格的单元测试什么样的单元测试才算合格，单元测试对代码的覆盖率要达到多少？ 迭代胖子从来都不是一口吃成的，怎么才能让你的代码越来越饱满，系统越来越稳定呢？唯有不断迭代。 结语上面这些问题，我将在后面的文章中挨个解读。希望你读完之后，也能化身为整洁代码的守护者。]]></content>
      <tags>
        <tag>整洁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java原子操作类，知多少？]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%8C%E7%9F%A5%E5%A4%9A%E5%B0%91%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前文我们介绍了Java并发编程中的两个关键字：volatile和synchronized。我们也知道了volatile虽然是轻量级，但不能保证原子性，synchronized可以保证原子性，但是比较重量级。 那么有没有一种简单的、性能高的方法来保证Java的原子操作呢？答案当然是有的，本文就为大家揭秘一些在JDK1.5时期加入Java家族的成员——Atomic包。Atomic包下包含了12个类，分为4种类型： 原子更新基本类型 原子更新数组 原子更新引用 原子更新字段 下面我来为大家一一引荐。 原子基本类型原子基本类型，从名称上就可以看出，是为基本类型提供原子操作的类。它们是以下3位： AtomicBoolean AtomicInteger AtomicLong 这三位属于近亲，提供的方法基本一模一样（AtomicBoolean支持方法略少）。 这里我们以AtomicInteger为例介绍这些方法。 void lazySet(int newValue)：使用此方法后最终会被设置成newValue。是线程不安全的。官方解释如下： As probably the last little JSR166 follow-up for Mustang, we added a “lazySet” method to the Atomic classes (AtomicInteger, AtomicReference, etc). This is a niche method that is sometimes useful when fine-tuning code using non-blocking data structures. The semantics are that the write is guaranteed not to be re-ordered with any previous write, but may be reordered with subsequent operations (or equivalently, might not be visible to other threads) until some other volatile write or synchronizing action occurs). The main use case is for nulling out fields of nodes in non-blocking data structures solely for the sake of avoiding long-term garbage retention; it applies when it is harmless if other threads see non-null values for a while, but you’d like to ensure that structures are eventually GCable. In such cases, you can get better performance by avoiding the costs of the null volatile-write. There are a few other use cases along these lines for non-reference-based atomics as well, so the method is supported across all of the AtomicX classes. For people who like to think of these operations in terms of machine-level barriers on common multiprocessors, lazySet provides a preceeding store-store barrier (which is either a no-op or very cheap on current platforms), but no store-load barrier (which is usually the expensive part of a volatile-write). 这里解释道：此方法不可与之前的写操作进行重排序，可以与之后的写操作进行重排序，知道出现volatile写或synchronizing操作。好处是比普通的set方法性能要好，前提是可以忍受其他线程在一段时间内读到的是旧数据。 int getAndSet(int newValue)：以原子方式更新，并且返回旧值。 boolean compareAndSet(int expect, int update)：如果输入的值等于expect的值，则以原子方式更新。 int getAndIncrement()：以原子方式自增，返回的是自增前的值。 int getAndDecrement()：与getAndIncrement相反，返回的是自减前的值。 int getAndAdd(int delta)：以原子方式，将当前值与输入值相加，返回的是计算前的值。 int incrementAndGet()：以原子方式自增，返回自增后的值。 int decrementAndGet()：以原子方式自减，返回自减后的值。 int addAndGet(int delta)：以原子方式，将当前值与输入值相加，返回的是计算后的值。 int getAndUpdate(IntUnaryOperator updateFunction)：Java1.8新增方法，以原子方式，按照指定方法更新当前数值，返回更新前的值，需要注意的是，提供的方法应该无副作用（side-effect-free），即两次执行结果相同，原因是如果由于线程争用导致更新失败会尝试再次执行该方法。 int updateAndGet(IntUnaryOperator updateFunction)：同样是Java1.8新增方法，与getAndUpdate唯一不同的是返回值是更新后的值。 int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)：与上述两个方法类似，操作数由参数x提供。返回更新前的值。 int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)：与getAndAccumulate方法作用相同，返回更新后的值。 方法介绍完了，AtomicInteger是怎么实现原子操作的呢？一起来看一下getAndIncrement方法的源码。 12345678/** * Atomically increments by one the current value. * * @return the previous value */public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 继续看Unsafe方法里的getAndIncrement方法 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 其中getIntVolatile方法是一个本地方法，根据对象以及偏移量获取对应的值。然后执行compareAndSwapInt方法，该方法根据对象和偏移量获取当当前值，与希望的值var5比较，如果相等，则将值更新为var5+var4。否则，进入循环。如果想要了解UnSafe类的其他方法，可以阅读源码或者参考这篇文章Java中Unsafe类详解。 原子数组下面的类是为数组中某个元素的更新提供原子操作的类。 AtomicIntegerArray AtomicLongArray AtomicReferenceArray 这三个类中的方法也都是类似的： 我们对AtomicIntegerArray中的方法进行介绍。 AtomicIntegerArray(int length)：构造函数，新建一个数组，传入AtomicIntegerArray。 AtomicIntegerArray(int[] array)：构造函数，将array克隆一份，传入AtomicIntegerArray，因此，修改AtomicIntegerArray中的元素时不会影响原数组。 int length()：获取数组长度。 int get(int i)：获取位置i的元素。 void set(int i, int newValue)：设置对应位置的值。 void lazySet(int i, int newValue)：类似AtomicInteger中的lazySet。 int getAndSet(int i, int newValue)：更新对应位置的值，返回更新前的值。 boolean compareAndSet(int i, int expect, int update)：比较对应位置的值与期望值，如果相等，则更新，返回true。如果不能返回false。 int getAndIncrement(int i)：对位置i的元素以原子方式自增，返回更新前的值。 int getAndDecrement(int i)：对位置i的元素以原子方式自减，返回更新前的值。 int getAndAdd(int i, int delta)：对位置i的元素以原子方式计算，返回更新前的值。 int incrementAndGet(int i)、int decrementAndGet(int i)、addAndGet(int i, int delta)：这三个方法与上面三个方法操作相同，区别是这三个方法返回的是更新后的值。 下面四个方法都是1.8才加入的，根据提供的参数中的方法对位置i的元素进行操作。区别是返回值不同以及是否提供操作数。 int getAndUpdate(int i, IntUnaryOperator updateFunction) int updateAndGet(int i, IntUnaryOperator updateFunction) int getAndAccumulate(int i, int x, IntBinaryOperator accumulatorFunction) int accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction) 原子数组类型同样也是调用Unsafe类的方法，因此原理与基本类型的原理相同，这里不做赘述。 原子引用类型前面讲到的类型都只能以原子的方式更新一个变量，有没有办法以原子方式更新多个变量呢？我们可以利用了面向对象的封装思想，可以把多个变量封装成一个类，再以原子的方式更新一个类对象。幸运的是，Atomic为我们提供了更新引用类型的方法。一起来认识一下他们吧。 AtomicReference AtomicReferenceFieldUpdater AtomicMarkableReference 同样的，先来看一下这三个类提供的方法有哪些。 方法的作用与AtomicInteger中的方法类似，不做过多介绍。 1234567891011/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */public final boolean compareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update);&#125; 这是compareAndSet方法的源码，同样是调用UnSafe类的CAS方法，因此，原子操作的原理也和基本类型相同。 原子更新字段类前文提到了AtomicReferenceFieldUpdater类，它更新的是类的字段，除了这个类，Atomic还提供了另外三个类用于更新类中的字段： AtomicIntegerFieldUpdater AtomicLongFieldUpdater AtomicStampedReference 使用这些类时需要注意以下几点： 更新字段必须有volatile关键字修饰 更新字段不能是类变量 使用前需要调用newUpdater()方法创建一个Updater 这三个类的方法语义也很明确，可以参考AtomicInteger。 总结Atomic包提供了足够的原子类供我们使用，想要真正完全理解这些类，还需要不断的练习。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile vs synchronized]]></title>
    <url>%2F2018%2F08%2F20%2Fvolatile-vs-synchronized%2F</url>
    <content type="text"><![CDATA[今天来聊一聊Java并发编程中两个常用的关键字：volatile和synchronized。 在介绍这两个关键字之前，首先要搞明白并发编程中的两个问题： 线程之间是如何通信的 线程之间如何同步 Java内存模型Java线程的通信由Java内存模型（JMM）控制，Java内存模型的抽象如图： Java线程之间的通信总是隐式进行，通信过程对程序员完全透明。多个线程通过读-写共享内存来实现通信。 图中线程A与线程B通信的具体步骤是： 线程A把更新过的共享变量刷新到主内存中 线程B从主内存读取共享变量 例如，共享变量x的初始值为0，线程A将x修改为1（x=x+1），线程B读取到的x就是1，对于程序员来讲，就是线程A给线程B发消息说它把x的值更新为1。 第一个问题搞明白了，再思考一下第二个问题。线程之间如何同步？在并发编程中，有三个重要的概念：原子性、可见性、一致性。 原子性在Java中，对基本数据类型的读取和赋值操作都属于原子操作。 12x = 10;x = x + 1; 上面两条语句中，第一句是原子操作，而第二句不是，为什么呢？实际上，第二句代码被编译为3条指令： 从内存中取x的值 x+1操作 计算结果存入内存 可见性当多个线程访问同一变量时，如果有一个线程修改了这个变量，那么其他线程立刻可以看到修改后的值。 有序性CPU执行指令是按照先后顺序执行的，但是指令的顺序并不一定等同于代码的顺序，编译器编译过程中，为了提高性能，常常进行指令重排序。这种重排序不会改变单线程的语义，也就是说，你写的一段代码如果是单线程执行，编译器可能对执行进行重排序，但不论如何排序，最后得到的结果都是相同的。 另外，如果存在数据依赖性，编译器不会改变依赖关系的执行顺序。数据依赖性是指两个操作访问同一个变量，其中一个是写操作，那么这两个操作就有数据依赖性。 重排序对应多线程有哪些影响呢，我们通过一段代码来看一下： 1234567891011121314class ReorderExample &#123; int a = 0; boolean flag = false; public void writer() &#123; a = 1; // 1 flag = true; // 2 &#125; Public void reader() &#123; if (flag) &#123; // 3 int i = a * a; // 4 …… &#125; &#125;&#125; 上述代码中，flag是变量a被初始化的标识，如果此时有两个线程A和B，A执行writer()方法，B执行reader()方法。由于1和2、3和4不存在数据依赖性，那么就有可能出现这种情况： A先执行语句2 B执行了语句3和4 A执行语句1 最终的结果并不是我们想要的，此时，重排序破坏了语义。 线程同步对于上面所说的线程同步问题如何避免呢？可以使用Java中的volatile和synchronized这两个关键字。 volatilevolatile关键字比较轻量级，只可以修饰变量。volatile修饰的变量，如果值被更新，会立即刷新主内存，而读volatile修饰的变量时，JMM会把线程对应的本地内存置为无效，从主内存中读取。这样volatile就可以保证线程的可见性。 volatile关键字在一定程度上可以保证有序性： 当第二个操作是volatile写时，不能进行重排序 当第一个操作是volatile读时，不能进行重排序 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序 为了实现这些语义，JMM采用屏障插入策略： 在volatile写操作前插入StoreStore屏障，后面插入StoreLoad屏障 在volatile读操作后面插入LoadLoad屏障和LoadStore屏障 也就是说，volatile写操作前的所有写操作都必须执行完，且需要等到volatile写操作执行后才能执行读操作。volatile读操作执行完之后才可以进行其他操作。也就是说volatile相当于一个屏障，其前面的操作不能放到volatile操作后面，后面的操作也不能放到volatile操作前面。 synchronizedsynchronized比较重量级，可以用来修饰方法。synchronized关键字是给修饰对象加锁，只有获得锁的线程才可以执行，执行完后释放锁。因此synchronized保证了原子性和可见性。 文中图片来源于网络]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊Git原理]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%81%8A%E8%81%8AGit%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[说起Git，相信大家都很熟悉了，毕竟作为程序猿，每天的业余时间除了吃饭睡觉就是逛一下全世界最大的开（tong）源（xing）代（jiao）码（you）网站GitHub了。在那里Git是每个人所要具备的最基本的技能。今天我们不聊Git的基本应用，来聊一聊Git的原理。 Git给自己的定义是一套内存寻址文件系统，当你在一个目录下执行git init命令时，会生成一个.git目录，它的目录结构是这样的： 1234567891011121314151617181920212223.git/├── branches├── config├── description├── HEAD├── hooks│ ├── applypatch-msg.sample│ ├── commit-msg.sample│ ├── post-update.sample│ ├── pre-applypatch.sample│ ├── pre-commit.sample│ ├── prepare-commit-msg.sample│ ├── pre-push.sample│ ├── pre-rebase.sample│ └── update.sample├── info│ └── exclude├── objects│ ├── info│ └── pack└── refs ├── heads └── tags 其中branches目录已经不再使用，description文件仅供GitWeb程序使用，config文件保存了项目的配置。 需要我们重点关注的是HEAD和index文件以及objects和refs目录。其中index中保存了暂存区的一些信息，这里不做过多介绍。 objects目录这个目录是用来存储Git对象的（包括tree对象、commit对象和blob对象），对于一个初始的Git仓库，objects目录下只有info和pack两个子目录，并没有常规文件。随着项目的进行，我们创建的文件，以及一些操作记录，都会作为Git对象被存储在这个目录下。 在该目录下，所有对象都会生成一个文件，并且有对应的SHA-1校验和，Git会创建以校验和前两位为名称的子目录，并以剩下的38位为名称来保存文件。 接下来让我们一起看一下当我们进行一次提交时，Git具体做了哪些事情。 12$ echo 'test content'&gt;test.txt$ git add . 执行上述命令后，objects目录结构如下： 12345.git/objects/├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── info└── pack 这里多了一个文件夹，如上面所述，这个就是Git为我们创建的一个对象，我们可以使用底层命令来看一下这个对象的类型以及它存储的是什么。 1234$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4blob$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4test content 可以看到，这是一个blob对象，存储内容就是我们刚刚创建的文件的内容。接下来继续执行提交操作。 1234567891011121314$ git commit -m 'test message'[master (root-commit) 2b00dca] test message 1 file changed, 1 insertion(+) create mode 100644 test.txt $ tree .git/objects/.git/objects/├── 2b│ └── 00dcae50af70bb5722033b3fe75281206c74da├── 80│ └── 865964295ae2f11d27383e5f9c0b58a8ef21da├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── info└── pack 此时objects目录下又多了两个对象。再用cat-file命令来查看一下这两个文件。 123456789101112$ git cat-file -t 2b00dcae50af70bb5722033b3fe75281206c74dacommit$ git cat-file -p 2b00dcae50af70bb5722033b3fe75281206c74datree 80865964295ae2f11d27383e5f9c0b58a8ef21daauthor jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534670725 +0800committer jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534670725 +0800test message$ git cat-file -t 80865964295ae2f11d27383e5f9c0b58a8ef21datree$ git cat-file -p 80865964295ae2f11d27383e5f9c0b58a8ef21da100644 blob d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt 可以看到一个是commit对象，一个是tree对象。commit对象通常包括4部分内容： 工作目录快照的Hash，即tree的值 提交的说明信息 提交者的信息 父提交的Hash值 由于我是第一次提交，所以这里没有父提交的Hash值。 tree对象可以理解为UNIX文件系统中的目录，保存了工作目录的tree对象和blob对象的信息。接下来我们再来看一下Git是如何进行版本控制的。 123456789101112131415161718192021222324252627282930313233343536373839echo 'version1'&gt;version.txt$ git add .$ git commit -m 'first version'[master 702193d] first version 1 file changed, 1 insertion(+) create mode 100644 version.txt$ echo 'version2'&gt;version.txt$ git add .$ git commit -m 'second version'[master 5333a75] second version 1 file changed, 1 insertion(+), 1 deletion(-)$ tree .git/objects/.git/objects/├── 1f│ └── a5aab2a3cf025d06479b9eab9a7f66f60dbfc1├── 29│ └── 13bfa5cf9fb6f893bec60ac11d86129d56fcbe├── 2b│ └── 00dcae50af70bb5722033b3fe75281206c74da├── 53│ └── 33a759c4bdcdc6095b4caac19743d9445ca516├── 5b│ └── dcfc19f119febc749eef9a9551bc335cb965e2├── 70│ └── 2193d62ffd797155e4e21eede20897890da12a├── 80│ └── 865964295ae2f11d27383e5f9c0b58a8ef21da├── d6│ └── 70460b4b4aece5915caf5c68d12f560a9fe3e4├── df│ └── 7af2c382e49245443687973ceb711b2b74cb4a├── info└── pack$ git cat-file -p 1fa5aab2a3cf025d06479b9eab9a7f66f60dbfc1100644 blob d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt100644 blob 5bdcfc19f119febc749eef9a9551bc335cb965e2 version.txt$ git cat-file -p 2913bfa5cf9fb6f893bec60ac11d86129d56fcbe100644 blob d670460b4b4aece5915caf5c68d12f560a9fe3e4 test.txt100644 blob df7af2c382e49245443687973ceb711b2b74cb4a version.txt Git将没有改变的文件的Hash值直接存入tree对象，对于有修改的文件，则会生成一个新的对象，将新的对象存入tree对象。我们再来看一下commit对象的信息。 1234567891011121314$ git cat-file -p 5333a759c4bdcdc6095b4caac19743d9445ca516tree 2913bfa5cf9fb6f893bec60ac11d86129d56fcbeparent 702193d62ffd797155e4e21eede20897890da12aauthor jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672270 +0800committer jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672270 +0800second version$ git cat-file -p 702193d62ffd797155e4e21eede20897890da12atree 1fa5aab2a3cf025d06479b9eab9a7f66f60dbfc1parent 2b00dcae50af70bb5722033b3fe75281206c74daauthor jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672248 +0800committer jackeyzhe &lt;jackeyzhe59@163.com&gt; 1534672248 +0800first version 此时的commit对象已经有parent信息了，这样我们就可以顺着parent一步步往回进行版本回退了。不过这样是比较麻烦的，我们一般习惯用的是git log查看提交记录。 refs目录在介绍refs目录之前，我们还是先来看一下该目录结构 123456789$ tree .git/refs/.git/refs/├── heads│ └── master└── tags2 directories, 1 file$ cat .git/refs/heads/master 5333a759c4bdcdc6095b4caac19743d9445ca516 在一个刚刚被初始化的Git仓库中，refs目录下只有heads和tags两个子目录，由于我们刚刚有过提交操作，所以git为我们自动生成了一个名为master的引用。master的内容是最后一次提交对象的Hash值。看到这里大家一定在想，如果我们对每次提交都创建一个这样的引用，不就不需要记住每次提交的Hash值了，只要看看引用的值，复制过来就可以退回到对应版本了。没错，这样是可以方便的退回，但是这样做的意义不大，因为我们并不需要频繁的退回，特别是比较古老的版本，退回的概率更是趋近于0。Git用这个引用做了更有意义的事，那就是分支。 当我新建一个分支时，git就会在.git/refs/heads目录下新建一个文件。当然新建的引用还是指向当前工作目录的最后一次提交，一般情况下我们不会主动去修改这些引用文件，不过如果一定要修改，Git为我们提供了一个update-ref命令。可以改变引用的值，使其指向不同的commit对象。 tags目录下的文件存储的是标签对应的commit，当为某次提交打上一个tag时，tags目录下就会被创建出一个命名为tag名的文件，值是此次提交的Hash值。 HEAD新建分支的时候，Git是怎么知道我们当前是在哪个分支的，Git又是如何实现分支切换的呢？答案就在HEAD这个文件中。 123456$ cat .git/HEAD ref: refs/heads/master$ git checkout test Switched to branch 'test'$ cat .git/HEAD ref: refs/heads/test 很明显，HEAD文件存储的就是我们当前分支的引用，当我们切换分支后再次进行提交操作时，Git就会读取HEAD对应引用的值，作为此次commit的parent。我们也可以通过symbolic-ref命令手动设置HEAD的值，但是不能设置refs以外的形式。 Packfiles到这里我们在文章开头所说的重点关注的目录和文件都介绍完毕了。但是作为一个文件系统，还存在一个问题，那就是空间。前文介绍过，当文件修改后进行提交时，Git会创建一份新的快照。这样长久下去，必定会占用很大的存储空间。而比较古老的版本的价值已经不大，所以要想办法清理出足够的空间供用户使用。 好消息是，Git拥有自己的gc（垃圾回收）方法。当仓库中有太多松散对象时，Git会调用git gc命令（当然我们也可以手动调用这个命令），将这些对象进行打包。打包后会出现两个新文件：一个idx索引文件和一个pack文件。索引文件包含了packfile的偏移信息，可以快速定位到文件。打包后，每个文件最新的版本的对象存的是完整的文件内容。而之前的版本只保存差异。这样就达到了压缩空间的目的。 Ending本文只介绍了Git的原理，如果对Git基本操作不熟悉的话，可以看看Pro Git。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo!]]></title>
    <url>%2F2018%2F08%2F05%2FHello-Hexo%2F</url>
    <content type="text"></content>
  </entry>
</search>
